{
  "name": "Image Process 阈值处理",
  "tagline": "风引",
  "body": "阈值分割\r\n1 /*===============================图像分割=====================================*/\r\n2 /*---------------------------------------------------------------------------*/\r\n3 /*手动设置阀值*/\r\n4 IplImage* binaryImg = cvCreateImage(cvSize(w, h),IPL_DEPTH_8U, 1);\r\n5 cvThreshold(smoothImgGauss,binaryImg,71,255,CV_THRESH_BINARY); \r\n6 cvNamedWindow(\"cvThreshold\", CV_WINDOW_AUTOSIZE );\r\n7 cvShowImage( \"cvThreshold\", binaryImg );\r\n8 //cvReleaseImage(&binaryImg); \r\n9  /*---------------------------------------------------------------------------*/\r\n10 /*自适应阀值 //计算像域邻域的平均灰度，来决定二值化的值*/\r\n11 IplImage* adThresImg = cvCreateImage(cvSize(w, h),IPL_DEPTH_8U, 1);\r\n12 double max_value=255;\r\n13 int adpative_method=CV_ADAPTIVE_THRESH_GAUSSIAN_C;//CV_ADAPTIVE_THRESH_MEAN_C\r\n14  int threshold_type=CV_THRESH_BINARY;\r\n15 int block_size=3;//阈值的象素邻域大小\r\n16  int offset=5;//窗口尺寸\r\n17   cvAdaptiveThreshold(smoothImgGauss,adThresImg,max_value,adpative_method,threshold_type,block_size,offset);\r\n18 cvNamedWindow(\"cvAdaptiveThreshold\", CV_WINDOW_AUTOSIZE );\r\n19 cvShowImage( \"cvAdaptiveThreshold\", adThresImg );\r\n20 cvReleaseImage(&adThresImg);\r\n21 /*---------------------------------------------------------------------------*/\r\n22 /*最大熵阀值分割法*/ \r\n23 IplImage* imgMaxEntropy = cvCreateImage(cvGetSize(imgGrey),IPL_DEPTH_8U,1);\r\n24 MaxEntropy(smoothImgGauss,imgMaxEntropy);\r\n25 cvNamedWindow(\"MaxEntroyThreshold\", CV_WINDOW_AUTOSIZE );\r\n26 cvShowImage( \"MaxEntroyThreshold\", imgMaxEntropy );//显示图像\r\n27   cvReleaseImage(&imgMaxEntropy ); \r\n28 /*---------------------------------------------------------------------------*/\r\n29 /*基本全局阀值法*/\r\n30 IplImage* imgBasicGlobalThreshold = cvCreateImage(cvGetSize(imgGrey),IPL_DEPTH_8U,1);\r\n31 cvCopyImage(srcImgGrey,imgBasicGlobalThreshold);\r\n32 int pg[256],i,thre; \r\n33 for (i=0;i<256;i++) pg[i]=0;\r\n34 for (i=0;i<imgBasicGlobalThreshold->imageSize;i++) // 直方图统计\r\n35   pg[(BYTE)imgBasicGlobalThreshold->imageData[i]]++; \r\n36 thre = BasicGlobalThreshold(pg,0,256); // 确定阈值\r\n37   cout<<\"The Threshold of this Image in BasicGlobalThreshold is:\"<<thre<<endl;//输出显示阀值\r\n38   cvThreshold(imgBasicGlobalThreshold,imgBasicGlobalThreshold,thre,255,CV_THRESH_BINARY); // 二值化 \r\n39   cvNamedWindow(\"BasicGlobalThreshold\", CV_WINDOW_AUTOSIZE );\r\n40 cvShowImage( \"BasicGlobalThreshold\", imgBasicGlobalThreshold);//显示图像\r\n41   cvReleaseImage(&imgBasicGlobalThreshold);\r\n42 /*---------------------------------------------------------------------------*/\r\n43 /*OTSU*/\r\n44 IplImage* imgOtsu = cvCreateImage(cvGetSize(imgGrey),IPL_DEPTH_8U,1);\r\n45 cvCopyImage(srcImgGrey,imgOtsu);\r\n46 int thre2;\r\n47 thre2 = otsu2(imgOtsu);\r\n48 cout<<\"The Threshold of this Image in Otsu is:\"<<thre2<<endl;//输出显示阀值\r\n49 cvThreshold(imgOtsu,imgOtsu,thre2,255,CV_THRESH_BINARY); // 二值化 \r\n50 cvNamedWindow(\"imgOtsu\", CV_WINDOW_AUTOSIZE );\r\n51 cvShowImage( \"imgOtsu\", imgOtsu);//显示图像 \r\n52 cvReleaseImage(&imgOtsu);\r\n53 /*---------------------------------------------------------------------------*/\r\n54 /*上下阀值法：利用正态分布求可信区间*/\r\n55 IplImage* imgTopDown = cvCreateImage( cvGetSize(imgGrey), IPL_DEPTH_8U, 1 );\r\n56 cvCopyImage(srcImgGrey,imgTopDown);\r\n57 CvScalar mean ,std_dev;//平均值、 标准差\r\n58 double u_threshold,d_threshold;\r\n59 cvAvgSdv(imgTopDown,&mean,&std_dev,NULL); \r\n60 u_threshold = mean.val[0] +2.5* std_dev.val[0];//上阀值\r\n61 d_threshold = mean.val[0] -2.5* std_dev.val[0];//下阀值\r\n62 //u_threshold = mean + 2.5 * std_dev; //错误\r\n63 //d_threshold = mean - 2.5 * std_dev;\r\n64 cout<<\"The TopThreshold of this Image in TopDown is:\"<<d_threshold<<endl;//输出显示阀值\r\n65 cout<<\"The DownThreshold of this Image in TopDown is:\"<<u_threshold<<endl;\r\n66 cvThreshold(imgTopDown,imgTopDown,d_threshold,u_threshold,CV_THRESH_BINARY_INV);//上下阀值\r\n67 cvNamedWindow(\"imgTopDown\", CV_WINDOW_AUTOSIZE );\r\n68 cvShowImage( \"imgTopDown\", imgTopDown);//显示图像 \r\n69 cvReleaseImage(&imgTopDown);\r\n70 /*---------------------------------------------------------------------------*/\r\n71 /*迭代法*/\r\n72 IplImage* imgIteration = cvCreateImage( cvGetSize(imgGrey), IPL_DEPTH_8U, 1 );\r\n73 cvCopyImage(srcImgGrey,imgIteration);\r\n74 int thre3,nDiffRec;\r\n75 thre3 =DetectThreshold(imgIteration, 100, nDiffRec);\r\n76 cout<<\"The Threshold of this Image in imgIteration is:\"<<thre3<<endl;//输出显示阀值\r\n77 cvThreshold(imgIteration,imgIteration,thre3,255,CV_THRESH_BINARY_INV);//上下阀值\r\n78 cvNamedWindow(\"imgIteration\", CV_WINDOW_AUTOSIZE );\r\n79 cvShowImage( \"imgIteration\", imgIteration);\r\n80 cvReleaseImage(&imgIteration);\r\n迭代\r\n1 /*======================================================================*/\r\n2 /* 迭代法*/\r\n3 /*======================================================================*/\r\n4 // nMaxIter：最大迭代次数；nDiffRec：使用给定阀值确定的亮区与暗区平均灰度差异值\r\n5 int DetectThreshold(IplImage*img, int nMaxIter, int& iDiffRec) //阀值分割：迭代法\r\n6 {\r\n7 //图像信息\r\n8 int height = img->height;\r\n9 int width = img->width;\r\n10 int step = img->widthStep/sizeof(uchar);\r\n11 uchar *data = (uchar*)img->imageData;\r\n12 \r\n13 iDiffRec =0;\r\n14 int F[256]={ 0 }; //直方图数组\r\n15 int iTotalGray=0;//灰度值和\r\n16 int iTotalPixel =0;//像素数和\r\n17 byte bt;//某点的像素值\r\n18 \r\n19 uchar iThrehold,iNewThrehold;//阀值、新阀值\r\n20 uchar iMaxGrayValue=0,iMinGrayValue=255;//原图像中的最大灰度值和最小灰度值\r\n21 uchar iMeanGrayValue1,iMeanGrayValue2;\r\n22 \r\n23 //获取(i,j)的值，存于直方图数组F\r\n24 for(int i=0;i<width;i++)\r\n25 {\r\n26 for(int j=0;j<height;j++)\r\n27 {\r\n28 bt = data[i*step+j];\r\n29 if(bt<iMinGrayValue)\r\n30 iMinGrayValue = bt;\r\n31 if(bt>iMaxGrayValue)\r\n32 iMaxGrayValue = bt;\r\n33 F[bt]++;\r\n34 }\r\n35 }\r\n36 \r\n37 iThrehold =0;//\r\n38 iNewThrehold = (iMinGrayValue+iMaxGrayValue)/2;//初始阀值\r\n39 iDiffRec = iMaxGrayValue - iMinGrayValue;\r\n40 \r\n41 for(int a=0;(abs(iThrehold-iNewThrehold)>0.5)&&a<nMaxIter;a++)//迭代中止条件\r\n42 {\r\n43 iThrehold = iNewThrehold;\r\n44 //小于当前阀值部分的平均灰度值\r\n45 for(int i=iMinGrayValue;i<iThrehold;i++)\r\n46 {\r\n47 iTotalGray += F[i]*i;//F[]存储图像信息\r\n48 iTotalPixel += F[i];\r\n49 }\r\n50 iMeanGrayValue1 = (uchar)(iTotalGray/iTotalPixel);\r\n51 //大于当前阀值部分的平均灰度值\r\n52 iTotalPixel =0;\r\n53 iTotalGray =0;\r\n54 for(int j=iThrehold+1;j<iMaxGrayValue;j++)\r\n55 {\r\n56 iTotalGray += F[j]*j;//F[]存储图像信息\r\n57 iTotalPixel += F[j]; \r\n58 }\r\n59 iMeanGrayValue2 = (uchar)(iTotalGray/iTotalPixel);\r\n60 \r\n61 iNewThrehold = (iMeanGrayValue2+iMeanGrayValue1)/2; //新阀值\r\n62 iDiffRec = abs(iMeanGrayValue2 - iMeanGrayValue1);\r\n63 }\r\n64 \r\n65 //cout<<\"The Threshold of this Image in imgIteration is:\"<<iThrehold<<endl;\r\n66 return iThrehold;\r\n67 }\r\n68\r\nOtsu代码一\r\n1 /*======================================================================*/\r\n2 /* OTSU global thresholding routine */\r\n3 /* takes a 2D unsigned char array pointer, number of rows, and */\r\n4 /* number of cols in the array. returns the value of the threshold */\r\n5 /*parameter: \r\n6 *image --- buffer for image\r\n7 rows, cols --- size of image\r\n8 x0, y0, dx, dy --- region of vector used for computing threshold\r\n9 vvv --- debug option, is 0, no debug information outputed\r\n10 */\r\n11 /*\r\n12 OTSU 算法可以说是自适应计算单阈值（用来转换灰度图像为二值图像）的简单高效方法。\r\n13 下面的代码最早由 Ryan Dibble提供，此后经过多人Joerg.Schulenburg, R.Z.Liu 等修改，补正。\r\n14 算法对输入的灰度图像的直方图进行分析，将直方图分成两个部分，使得两部分之间的距离最大。\r\n15 划分点就是求得的阈值。\r\n16 */\r\n17 /*======================================================================*/\r\n18 int otsu (unsigned char*image, int rows, int cols, int x0, int y0, int dx, int dy, int vvv)\r\n19 {\r\n20 \r\n21 unsigned char*np; // 图像指针\r\n22 int thresholdValue=1; // 阈值\r\n23 int ihist[256]; // 图像直方图，256个点\r\n24 \r\n25 int i, j, k; // various counters\r\n26 int n, n1, n2, gmin, gmax;\r\n27 double m1, m2, sum, csum, fmax, sb;\r\n28 \r\n29 // 对直方图置零\r\n30 memset(ihist, 0, sizeof(ihist));\r\n31 \r\n32 gmin=255; gmax=0;\r\n33 // 生成直方图\r\n34 for (i = y0 +1; i < y0 + dy -1; i++) \r\n35 {\r\n36 np = (unsigned char*)image[i*cols+x0+1];\r\n37 for (j = x0 +1; j < x0 + dx -1; j++)\r\n38 {\r\n39 ihist[*np]++;\r\n40 if(*np > gmax) gmax=*np;\r\n41 if(*np < gmin) gmin=*np;\r\n42 np++; /* next pixel */\r\n43 }\r\n44 }\r\n45 \r\n46 // set up everything\r\n47 sum = csum =0.0;\r\n48 n =0;\r\n49 \r\n50 for (k =0; k <=255; k++) \r\n51 {\r\n52 sum += (double) k * (double) ihist[k]; /* x*f(x) 质量矩*/\r\n53 n += ihist[k]; /* f(x) 质量 */\r\n54 }\r\n55 \r\n56 if (!n) \r\n57 {\r\n58 // if n has no value, there is problems...\r\n59 fprintf (stderr, \"NOT NORMAL thresholdValue = 160\\n\");\r\n60 return (160);\r\n61 }\r\n62 \r\n63 // do the otsu global thresholding method\r\n64 fmax =-1.0;\r\n65 n1 =0;\r\n66 for (k =0; k <255; k++)\r\n67 {\r\n68 n1 += ihist[k];\r\n69 if (!n1) \r\n70 { \r\n71 continue; \r\n72 }\r\n73 n2 = n - n1;\r\n74 if (n2 ==0)\r\n75 { \r\n76 break; \r\n77 }\r\n78 csum += (double) k *ihist[k];\r\n79 m1 = csum / n1;\r\n80 m2 = (sum - csum) / n2;\r\n81 sb = (double) n1 *(double) n2 *(m1 - m2) * (m1 - m2);\r\n82 /* bbg: note: can be optimized. */\r\n83 if (sb > fmax) \r\n84 {\r\n85 fmax = sb;\r\n86 thresholdValue = k;\r\n87 }\r\n88 }\r\n89 \r\n90 // at this point we have our thresholding value\r\n91 \r\n92 // debug code to display thresholding values\r\n93 if ( vvv &1 )\r\n94 fprintf(stderr,\"# OTSU: thresholdValue = %d gmin=%d gmax=%d\\n\",\r\n95 thresholdValue, gmin, gmax);\r\n96 \r\n97 return(thresholdValue);\r\n98 } \r\nOtsu代码二\r\n1 /*======================================================================*/\r\n2 /* OTSU global thresholding routine */\r\n3 /*======================================================================*/\r\n4 int otsu2 (IplImage *image)\r\n5 {\r\n6 int w = image->width;\r\n7 int h = image->height;\r\n8 \r\n9 unsigned char*np; // 图像指针\r\n10 unsigned char pixel;\r\n11 int thresholdValue=1; // 阈值\r\n12 int ihist[256]; // 图像直方图，256个点\r\n13 \r\n14 int i, j, k; // various counters\r\n15 int n, n1, n2, gmin, gmax;\r\n16 double m1, m2, sum, csum, fmax, sb;\r\n17 \r\n18 // 对直方图置零...\r\n19 memset(ihist, 0, sizeof(ihist));\r\n20 \r\n21 gmin=255; gmax=0;\r\n22 // 生成直方图\r\n23 for (i =0; i < h; i++) \r\n24 {\r\n25 np = (unsigned char*)(image->imageData + image->widthStep*i);\r\n26 for (j =0; j < w; j++) \r\n27 {\r\n28 pixel = np[j];\r\n29 ihist[ pixel]++;\r\n30 if(pixel > gmax) gmax= pixel;\r\n31 if(pixel < gmin) gmin= pixel;\r\n32 }\r\n33 }\r\n34 \r\n35 // set up everything\r\n36 sum = csum =0.0;\r\n37 n =0;\r\n38 \r\n39 for (k =0; k <=255; k++) \r\n40 {\r\n41 sum += k * ihist[k]; /* x*f(x) 质量矩*/\r\n42 n += ihist[k]; /* f(x) 质量 */\r\n43 }\r\n44 \r\n45 if (!n) \r\n46 {\r\n47 // if n has no value, there is problems...\r\n48 //fprintf (stderr, \"NOT NORMAL thresholdValue = 160\\n\");\r\n49 thresholdValue =160;\r\n50 goto L;\r\n51 }\r\n52 \r\n53 // do the otsu global thresholding method\r\n54 fmax =-1.0;\r\n55 n1 =0;\r\n56 for (k =0; k <255; k++) \r\n57 {\r\n58 n1 += ihist[k];\r\n59 if (!n1) { continue; }\r\n60 n2 = n - n1;\r\n61 if (n2 ==0) { break; }\r\n62 csum += k *ihist[k];\r\n63 m1 = csum / n1;\r\n64 m2 = (sum - csum) / n2;\r\n65 sb = n1 * n2 *(m1 - m2) * (m1 - m2);\r\n66 /* bbg: note: can be optimized. */\r\n67 if (sb > fmax)\r\n68 {\r\n69 fmax = sb;\r\n70 thresholdValue = k;\r\n71 }\r\n72 }\r\n73 \r\n74 L:\r\n75 for (i =0; i < h; i++) \r\n76 {\r\n77 np = (unsigned char*)(image->imageData + image->widthStep*i);\r\n78 for (j =0; j < w; j++) \r\n79 {\r\n80 if(np[j] >= thresholdValue)\r\n81 np[j] =255;\r\n82 else np[j] =0;\r\n83 }\r\n84 }\r\n85 \r\n86 //cout<<\"The Threshold of this Image in Otsu is:\"<<thresholdValue<<endl;\r\n87 return(thresholdValue);\r\n88 }\r\n最大熵阀值\r\n1 /*============================================================================\r\n2 = 代码内容：最大熵阈值分割 \r\n3 = 修改日期:2009-3-3 \r\n4 = 作者:crond123 \r\n5 = 博客:http://blog.csdn.net/crond123/\r\n6 = E_Mail:crond123@163.com \r\n7 ===============================================================================*/\r\n8 // 计算当前位置的能量熵\r\n9 double caculateCurrentEntropy(CvHistogram * Histogram1,int cur_threshold,entropy_state state)\r\n10 {\r\n11 int start,end;\r\n12 int total =0;\r\n13 double cur_entropy =0.0;\r\n14 if(state == back) \r\n15 {\r\n16 start =0;\r\n17 end = cur_threshold; \r\n18 }\r\n19 else \r\n20 {\r\n21 start = cur_threshold;\r\n22 end =256; \r\n23 } \r\n24 for(int i=start;i<end;i++) \r\n25 {\r\n26 total += (int)cvQueryHistValue_1D(Histogram1,i);//查询直方块的值 P304\r\n27 }\r\n28 for(int j=start;j<end;j++)\r\n29 {\r\n30 if((int)cvQueryHistValue_1D(Histogram1,j)==0)\r\n31 continue;\r\n32 double percentage = cvQueryHistValue_1D(Histogram1,j)/total;\r\n33 /*熵的定义公式*/\r\n34 cur_entropy +=-percentage*logf(percentage);\r\n35 /*根据泰勒展式去掉高次项得到的熵的近似计算公式\r\n36 cur_entropy += percentage*percentage;*/ \r\n37 }\r\n38 return cur_entropy;\r\n39 // return (1-cur_entropy);\r\n40 }\r\n41 \r\n42 //寻找最大熵阈值并分割\r\n43 void MaxEntropy(IplImage *src,IplImage *dst)\r\n44 {\r\n45 assert(src != NULL);\r\n46 assert(src->depth ==8&& dst->depth ==8);\r\n47 assert(src->nChannels ==1);\r\n48 CvHistogram * hist = cvCreateHist(1,&HistogramBins,CV_HIST_ARRAY,HistogramRange);//创建一个指定尺寸的直方图\r\n49 //参数含义：直方图包含的维数、直方图维数尺寸的数组、直方图的表示格式、方块范围数组、归一化标志\r\n50 cvCalcHist(&src,hist);//计算直方图\r\n51 double maxentropy =-1.0;\r\n52 int max_index =-1;\r\n53 // 循环测试每个分割点，寻找到最大的阈值分割点\r\n54 for(int i=0;i<HistogramBins;i++) \r\n55 {\r\n56 double cur_entropy = caculateCurrentEntropy(hist,i,object)+caculateCurrentEntropy(hist,i,back);\r\n57 if(cur_entropy>maxentropy)\r\n58 {\r\n59 maxentropy = cur_entropy;\r\n60 max_index = i;\r\n61 }\r\n62 }\r\n63 cout<<\"The Threshold of this Image in MaxEntropy is:\"<<max_index<<endl;\r\n64 cvThreshold(src, dst, (double)max_index,255, CV_THRESH_BINARY);\r\n65 cvReleaseHist(&hist);\r\n66 }\r\n基本全局阀值法\r\n1 /*============================================================================\r\n2 = 代码内容：基本全局阈值法 \r\n3 ==============================================================================*/\r\n4 int BasicGlobalThreshold(int*pg,int start,int end)\r\n5 { // 基本全局阈值法\r\n6 int i,t,t1,t2,k1,k2;\r\n7 double u,u1,u2; \r\n8 t=0; \r\n9 u=0;\r\n10 for (i=start;i<end;i++) \r\n11 {\r\n12 t+=pg[i]; \r\n13 u+=i*pg[i];\r\n14 }\r\n15 k2=(int) (u/t); // 计算此范围灰度的平均值 \r\n16 do \r\n17 {\r\n18 k1=k2;\r\n19 t1=0; \r\n20 u1=0;\r\n21 for (i=start;i<=k1;i++) \r\n22 { // 计算低灰度组的累加和\r\n23 t1+=pg[i]; \r\n24 u1+=i*pg[i];\r\n25 }\r\n26 t2=t-t1;\r\n27 u2=u-u1;\r\n28 if (t1) \r\n29 u1=u1/t1; // 计算低灰度组的平均值\r\n30 else \r\n31 u1=0;\r\n32 if (t2) \r\n33 u2=u2/t2; // 计算高灰度组的平均值\r\n34 else \r\n35 u2=0;\r\n36 k2=(int) ((u1+u2)/2); // 得到新的阈值估计值\r\n37 }\r\n38 while(k1!=k2); // 数据未稳定，继续\r\n39 //cout<<\"The Threshold of this Image in BasicGlobalThreshold is:\"<<k1<<endl;\r\n40 return(k1); // 返回阈值\r\n41 }\r\n``",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}